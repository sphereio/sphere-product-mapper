var Connection, Q, Sftp, _;

Q = require('q');

_ = require('underscore');

Connection = require('ssh2');

Sftp = (function() {
  function Sftp(_options) {
    this._options = _options != null ? _options : {};
  }


  /**
   * Get directory entries.
   * @param {Object} sftp SFTP handle
   * @param {String} dirName Directory to get the entries from
   * @return {Promise} A promise, fulfilled with an {Array} or rejected with an error
   */

  Sftp.prototype.listFiles = function(sftp, dirName) {
    var deferred;
    deferred = Q.defer();
    sftp.opendir(dirName, function(err, handle) {
      if (err) {
        return deferred.reject(err);
      } else {
        return sftp.readdir(handle, function(err, list) {
          if (err) {
            deferred.reject(err);
          } else {
            if (list === false) {
              deferred.resolve([]);
            } else {
              deferred.resolve(list);
            }
          }
          return sftp.close(handle);
        });
      }
    });
    return deferred.promise;
  };

  Sftp.prototype.readFile = function(fileName) {};

  Sftp.prototype.saveFile = function(path, fileName, content) {};


  /**
   * Download a file.
   * @param {Object} sftp SFTP handle
   * @param {String} remotePath Path of the remote file
   * @param {String} localPath Download file to this path
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.getFile = function(sftp, remotePath, localPath) {
    var deferred;
    deferred = Q.defer();
    sftp.fastGet(remotePath, localPath, function(err) {
      if (err) {
        return deferred.reject(err);
      } else {
        return deferred.resolve();
      }
    });
    return deferred.promise;
  };


  /**
   * Move/rename a remote resource.
   * @param {Object} sftp SFTP handle
   * @param {String} srcPath Source path of the remote resource
   * @param {String} destPath Destination path of the remote resource
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.moveFile = function(sftp, srcPath, destPath) {
    var deferred;
    deferred = Q.defer();
    sftp.rename(srcPath, destPath, function(err) {
      if (err) {
        return deferred.reject(err);
      } else {
        return deferred.resolve();
      }
    });
    return deferred.promise;
  };


  /**
   * Starts a SFTP session.
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.openSftp = function() {
    var deferred;
    deferred = Q.defer();
    this.conn = new Connection();
    this.conn.on('ready', (function(_this) {
      return function() {
        console.log('Connection :: ready');
        return _this.conn.sftp(function(err, sftp) {
          if (err) {
            return deferred.reject(err);
          } else {
            sftp.on('end', function() {
              return console.log('SFTP :: end');
            });
            return deferred.resolve(sftp);
          }
        });
      };
    })(this));
    this.conn.on('error', function(err) {
      return console.log('Connection :: error - msg: ' + err);
    });
    this.conn.on('close', function(hadError) {
      return console.log('Connection :: close - had error: ' + hadError);
    });
    this.conn.on('end', function() {
      return console.log('Connection :: end');
    });
    this.conn.connect({
      host: this._options.host,
      username: this._options.username,
      password: this._options.password
    });
    return deferred.promise;
  };


  /**
   * Close SFTP session and underlying connection.
   * @param {Object} sftp SFTP handle
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.close = function(sftp) {
    if (sftp) {
      sftp.end();
    }
    return this.conn.end();
  };

  return Sftp;

})();

module.exports = Sftp;
