var Q, _;

Q = require('q');

_ = require('underscore');

_.mixin(require('./underscore'));

module.exports = {

  /**
   * Process promises in batches using a recursive function.
   * Supports promise subscription of progress notifications.
   *
   * @param {Array} promises A list of promises
   * @param {Number} limit Number of parallel requests to be sent in batch
   * @return {Promise} A promise, fulfilled with an {Array} of results or rejected with an error
   * @example
   * 1) simple batch process
   *   allPromises = [p1, p2, p3, ...]
   *   batch(allPromises)
   *   .then (results) ->
   *   .fail (error) ->
   *
   * 2) batch process with custom limit
   *   allPromises = [p1, p2, p3, ...]
   *   batch(allPromises, 30)
   *   .then (results) ->
   *   .fail (error) ->
   *
   * 3) batch process with notification subscription
   *   allPromises = [p1, p2, p3, ...]
   *   batch(allPromises)
   *   .then (results) ->
   *   .progress (progress) -> console.log "#{progress.percentage}% processed"
   *   .fail (error) ->
   */
  all: function(promises, limit) {
    var deferred, totalPromises, _processInBatches;
    if (limit == null) {
      limit = 50;
    }
    deferred = Q.defer();
    totalPromises = _.size(promises);
    _processInBatches = function(currentPromises, limit, accumulator) {
      var head;
      if (accumulator == null) {
        accumulator = [];
      }
      head = _.head(currentPromises, limit);
      return Q.all(head).then(function(results) {
        var allResults, tail;
        deferred.notify({
          percentage: _.percentage(totalPromises - _.size(currentPromises), totalPromises),
          value: results
        });
        allResults = accumulator.concat(results);
        if (_.size(head) < limit) {
          return deferred.resolve(allResults);
        } else {
          tail = _.tail(currentPromises, limit);
          return _processInBatches(tail, limit, allResults);
        }
      }).fail(function(err) {
        return deferred.reject(err);
      });
    };
    _processInBatches(promises, limit);
    return deferred.promise;
  }
};
